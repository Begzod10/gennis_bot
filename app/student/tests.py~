#tests
import os
import asyncio
import requests
from aiogram import Router, types, F
from aiogram.fsm.context import FSMContext
from aiogram.fsm.state import StatesGroup, State
from aiogram.types import KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove

student_routers = Router()
GENNIS_TOKEN = os.getenv(
    "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJmcmVzaCI6ZmFsc2UsImlhdCI6MTc2Mjg1NjY4NCwianRpIjoiYmFhZTczZTAtNmU4Yy00NDU1LWEwYTktNGU4NjYzMzhiNjY5IiwidHlwZSI6ImFjY2VzcyIsInN1YiI6IjhkMDI3NzJjNTE5MzExZjBhNTQ4MzFkODQyNzBhMjIwIiwibmJmIjoxNzYyODU2Njg0LCJjc3JmIjoiZmY2OGFkZDktNGEyOS00OGZiLWFmMzEtMDFjZDliNmE2ZGVhIiwiZXhwIjoxNzYyOTQzMDg0fQ.kyqMRFUS8AcPDqMJ8yLD0duqw0Q0wwiGgGgAkcfdKlc")
TEST_LIST_URL = "https://classroom.gennis.uz/api/pisa/test/crud/34"
active_questions = {}
HEADERS = lambda token: {
    "Authorization": f"Bearer {token}",
    "Accept": "application/json",
    "User-Agent": "GennisBot/1.0"
}


class TestStates(StatesGroup):
    question_number = State()
    score = State()
    questions = State()
    waiting_answer = State()
    test_id = State()
    answered_questions = State()


def save_result(user_id, username, score, total, percent, answered_questions):
    print(f"Natija: {user_id}, {username}, {score}/{total} ({percent}%), Savollar: {answered_questions}")


def get_tests():
    try:
        resp = requests.get(TEST_LIST_URL, headers=HEADERS(GENNIS_TOKEN))
        data = resp.json()
        if isinstance(data, dict):
            return [{"id": data.get("id", 34), "name": data.get("name", "Noma ºlum test")}]
        elif isinstance(data, list):
            return [{"id": t["id"], "name": t["name"]} for t in data if "id" in t and "name" in t]
    except Exception as e:
        print(f"Xato test olishda: {e}")
    return []


def student_basic_reply_keyboard_test_type():
    return ReplyKeyboardMarkup(
        keyboard=[[KeyboardButton(text="üèÅ Onlayn test yechish")], [KeyboardButton(text="‚¨ÖÔ∏è Orqaga")]],
        resize_keyboard=True
    )


@student_routers.message(F.text == "üèÅ Onlayn test yechish")
async def show_tests(message: types.Message, state: FSMContext):
    tests = get_tests()
    if not tests:
        await message.answer("üö´ Hozircha testlar mavjud emas.")
        return
    buttons = [[KeyboardButton(text=t["name"])] for t in tests]
    buttons.append([KeyboardButton(text="‚¨ÖÔ∏è Orqaga")])
    keyboard = ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)
    await message.answer("üìã Iltimos, testni tanlang:", reply_markup=keyboard)
    await state.update_data(tests=tests)


@student_routers.message(F.text == "‚¨ÖÔ∏è Orqaga")
async def back_to_menu(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("üëÜ Iltimos, quyidagilardan birini tanlang:",
                         reply_markup=student_basic_reply_keyboard_test_type())


@student_routers.message()
async def select_test(message: types.Message, state: FSMContext):
    if message.text == "‚¨ÖÔ∏è Orqaga":
        return
    data = await state.get_data()
    tests = data.get("tests", [])
    selected = next((t for t in tests if t["name"] == message.text), None)
    if not selected:
        return
    await message.answer(f"‚úÖ Siz tanladingiz: <b>{selected['name']}</b>", parse_mode="HTML")
    await message.answer("üß† Test yuklanmoqda...", reply_markup=ReplyKeyboardRemove())

    test_url = f"https://classroom.gennis.uz/api/pisa/student/get/test/{selected['id']}"
    resp = requests.get(test_url, headers=HEADERS(GENNIS_TOKEN))
    test_data = resp.json()

    questions = []
    for block in test_data.get("pisa_blocks_right", []):
        options = block.get("answers", [])
        if options:
            questions.append({
                "id": block.get("id"),
                "text": block.get("q", "Savol matni yo'q"),
                "answers": [{"text": o, "isTrue": idx == block.get("correct_answer_index", 0)} for idx, o in
                            enumerate(options)]
            })
    if not questions:
        await message.answer("‚ùóÔ∏è Bu testda savollar topilmadi.", reply_markup=student_basic_reply_keyboard_test_type())
        return

    await state.update_data(question_number=0, score=0, questions=questions, test_id=selected["id"],
                            answered_questions=[])
    await message.answer(f"üìò Test: <b>{selected['name']}</b>\nüìÑ Savollar soni: {len(questions)}\n\nBoshlaymiz!",
                         parse_mode="HTML")
    await state.set_state(TestStates.question_number)
    await send_question(message, state)


async def send_question(message: types.Message, state: FSMContext):
    data = await state.get_data()
    q_num = data.get("question_number", 0)
    questions = data.get("questions", [])

    if q_num >= len(questions):
        await finish_test(message, state)
        return

    q = questions[q_num]
    options = q.get("answers", [])
    question_text = q.get("text", "Savol topilmadi")
    buttons = [[KeyboardButton(text=str(i + 1))] for i in range(len(options))]
    buttons.append([KeyboardButton(text="‚ùå Testdan chiqish")])
    keyboard = ReplyKeyboardMarkup(keyboard=buttons, resize_keyboard=True)
    await message.answer(f"{question_text}\n\n" + "\n".join(f"{i + 1}. {opt['text']}" for i, opt in enumerate(options)),
                         reply_markup=keyboard)


@student_routers.message(TestStates.question_number, F.text == "‚ùå Testdan chiqish")
async def exit_test(message: types.Message, state: FSMContext):
    await state.clear()
    await message.answer("üö™ Siz testdan chiqdingiz.", reply_markup=student_basic_reply_keyboard_test_type())


@student_routers.message(TestStates.question_number, F.text.regexp(r"^\d+$"))
async def answer_question(message: types.Message, state: FSMContext):
    data = await state.get_data()
    q_num = data.get("question_number", 0)
    score = data.get("score", 0)
    questions = data.get("questions", [])
    answered_questions = data.get("answered_questions", [])

    if q_num >= len(questions):
        await finish_test(message, state)
        return

    q = questions[q_num]
    options = q.get("answers", [])
    user_answer = int(message.text)
    correct_index = next((i + 1 for i, a in enumerate(options) if a["isTrue"]), None)
    answered_questions.append(q["text"])

    if 1 <= user_answer <= len(options):
        if user_answer == correct_index:
            score += 1
            await message.answer("‚úÖ To‚Äòg‚Äòri!")
        else:
            correct_text = options[correct_index - 1]["text"] if correct_index else "?"
            await message.answer(f"‚ùå Noto‚Äòg‚Äòri!\nTo‚Äòg‚Äòri javob: {correct_text}")

    await state.update_data(question_number=q_num + 1, score=score, answered_questions=answered_questions)
    await send_question(message, state)


async def finish_test(message: types.Message, state: FSMContext):
    data = await state.get_data()
    score = data.get("score", 0)
    total = len(data.get("questions", []))
    percent = round((score / total) * 100) if total else 0
    answered_questions = data.get("answered_questions", [])

    save_result(user_id=message.from_user.id, username=message.from_user.username,
                score=score, total=total, percent=percent, answered_questions=answered_questions)

    await message.answer(
        f"‚úÖ Test tugadi!\nSiz {score}/{total} to‚Äòg‚Äòri javob berdingiz.\nüìä Foiz: {percent}%\nüìÑ Javob bergan savollar:\n" + "\n".join(
            answered_questions),
        reply_markup=student_basic_reply_keyboard_test_type())
    await state.clear()
